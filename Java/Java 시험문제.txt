1 부터 10까지 출력하는 프로그래밍 손코딩 하기 (코드 암기)
public class Ex_1 {
	public static void main(String[] args) {
		for(int i=1; i<11; i++){
			System.out.println(i); 
		}
	}
}

OOP
객체지향적인 프로그래밍(Object-Oriented Programming)
객체들의 유기적인 관계를 통해서 프로세스가 진행됨
애플리케이션을 구성하는 요소들을 객체로 바라보고, 
객체들을 유기적으로 연결하여 프로그래밍 하는 것

함수형언어, 인터프리터, 컴파일러
함수형 프로그래밍 언어 - 수학의 함수를 프로그래밍 언어 설계에 적극적으로 반영한 것. 함수도 값으로 취급. 
대입문을 사용하지 않는 프로그래밍. 외부 환경으로부터 독립적임.
함수의 동작에 의한 변수의 부수적인 값 변경을 원천 배제함으로써 이런 종류의 오류들을 방지하는 것.
문제의 소지가 있는 일은 하지 않는 코딩 방식.

인터프리터 -  고급 언어(사람이 이해하기 쉽게 작성된 프로그래밍 언어)로 작성된 프로그램을 한 줄 단위로 받아들여 번역하고, 
번역과 동시에 프로그램을 한 줄 단위로 즉시 실행시키는 프로그램. (ex. 뉴스 수화)

컴파일러 - 소스 코드 전체를 한 번에 기계어로 번역해서 CPU에게 전달하여 결과값을 만들어냄.

OOP 4가지 특징
캡슐화 - 하나의 객체에 특정한 목적으로 변수나 메소드를 하나로 묶는 것(ex. TV리모컨)
추상화 - 객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법(ex. 세상 모든TV의 공통된 기능)
다형성 - 형태는 같지만 다른 기능을 하는 것. 오버라이딩, 오버로딩
상속성 - 기존 상위 클래스에 근거하여 새롭게 클래스와 행위를 정의하게 함. 코드의 재사용 목적

OOP 5대 원칙 SOLID
단일 책임의 원칙 - 모든 Class는 하나의 책임만 가지고 캡슐화되어야 함.
개방 폐쇄 원칙 - 클래스, 모듈 함수 등의 소프트웨어 개체는 확장에 대해 열려있어야하고, 수정에 대해서는 닫혀 있어야 함.
리스코프 치환 원칙 - 부모 Class가 들어갈 자리에 자식 Class를 넣어도 잘 구동되어야 하는 원칙.
인터페이스 분리 원칙 - 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안되된다는 원칙.
의존관계 역전 원칙 - 상위 모듈과 하위 모듈 둘 다 추상화에 의존해야 함. 
추상화는 세부사항에 의존하지 않음. 세부사항은 추상화에 의해 달라져야 함.

컴파일 언어, 인터프리터 언어, 스크립트 언어
컴파일 언어 - 반드시 기계어로 컴파일되어야만 실행시킬 수 있는 프로그래밍 언어. (ex. 0101001)
인터프리터 언어 - 컴파일러를 거쳐서 기계어로 변환되지 않고 바로 실행되는 프로그래밍 언어. 사람이 이해하기 쉬운 언어.
스크립트 언어 - 응용 소프트웨어를 제어하기 위해 사용하는 프로그래밍 언어. (ex. JavaScript)

Interface 란?
구현된 것 없이 밑그림만 있는 기본 설계도.
동일한 목적 하에 동일한 기능을 수행하게끔 강제하는 것.
자바의 다형성을 극대화하여 개발코드 수정을 줄이고 프로그램 유지보수성을 높이기 위해 인터페이스를 사용.
일반 메서드 또는 멤버 변수를 가질 수 없고, 추상 메서드와 상수만을 멤버로 가질 수 있음.
인터페이스 자체로는 인스턴스를 생성할 수 없지만, implements를 사용해서 구현 할 수 있음.

추상클래스와 인터페이스의 차이
사용 의도의 차이. 추상클래스는 다중 상속이 불가능하지만 인터페이스는 가능함.
공통된 기능 사용 여부 차이. 추상 클래스는 조상 클래스의 기능을 그대로 가져와 사용 가능하지만 인터페이스는 다른 조상클래스에서 그 기능이 필요할 때 사용.

접근 제한자
public - 모든 접근을 허용
private - 현재 객체 내에서만 허용
protected - 같은 패키지(폴더)에 있는 객체와 상속관계의 객체들만 허용
default - 같은 패키지(폴더)에 있는 객체들만 허용

static 전역변수 사용법
메모리에 한 번 할당되어 프로그램이 종료될 때 해제되는 것을 의미, 다른 파일에서도 해당 변수에 접근 가능.
변수, 메소드, 클래스 앞에 static을 붙여서 사용.

상수 정의 및 사용 법
상수- 변하지 않거나 일정한 값을 가진 수나 양을 의미.
final이라는 예약어를 사용하여 선언.

스트림 API
컬렉션, 배열등의 저장 요소를 하나씩 참조하며 함수형 인터페이스(람다식)를 적용하고 반복적으로 처리할 수 있도록 해주는 기능

Lambda Expression,
함수를 하나의 식으로 표현한 것. 익명 함수. 
메서드의 인수로 전달될 수 있고, 변수로 저장될 수 있음.

functional interface
@FunctionalInterface 어노테이션사용.
함수를 객체처럼 다룰 수 있게 해주는 어노테이션. 
인터페이스에 선언하여 단 하나의 추상 메서드만을 갖도록 제한하는 역할.

optional 이란?
Java의 NPE(NullPointerException)값에 대한 처리를 깔끔하게 해주는 역할.
Optional<T>로 사용.

인터페이스의 디폴트 메소드란?
인터페이스의 기본 구현을 가지는 메서드. 
앞에 default 예약어를 붙이며, 추상 메서드와 달리 일반 메서드처럼 몸통{}이 있어야 함.
인터페이스를 구현한 클래스에서 디폴트 메서드 오버라이딩 가능.


java의 non-static 멤버와 static 멤버의 차이
non-static 멤버는 객체마다 별도로 존재하고 인스턴스 멤버라고 부름. 
다른 클래스에 공유되지 않음. 
객체가 사라지면 멤버도 사라짐.

static 멤버는 객체 내부가 아닌 별도의 공간에 생성하고 클래스 멤버라고 부름. 
다른 클래스에 공유 가능. 
멤버는 프로그램이 종료될 때 사라짐.

Override
부모 클래스에서 상속받은 메서드를 자식 클래스에서 다시 재정의하여 사용하는 것

Overloading
같은 이름의 메서드를 사용하지만 메서드마다 사용 용도가 다르고 결과도 다르게 구현하는 것
메서드이름은 같지만 매개변수 갯수, 데이터 타입이 다름

제너릭이란? 제너릭 사용방법
데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방법.
사용 방법 - 객체<타입> 객체명 = new 객체<타입>();

Final 의 쓰임새.. 멤버변수, 메소드, 클래스.. 각각 설명
멤버변수 - 상수가 됨.
메소드 - 상속받은 클래스에서 부모의 final 메서드를 재정의 할 수 없음.
클래스 - 최종상태가 되어 상속 불가. 

메소드의 override 를 막는 방법
특정 메소드 앞에 final을 붙임.

동기화와 비동기화의 차이(Syncronous vs Asyncronous)
동기화 - 실행 중인 명령에 대해 동시 접근하는 것을 제한함. 
순차적으로 접근. 
다음에 실행될 명령은 현재 실행 중인 명령 종료 시 까지 대기 (대기시간 버퍼링 발생)
서버와 클라이언트가 주고 받는것이 동시에 이루어지는 형태
시간적인 동기화가 필요한 곳에 많이 사용 (ex. 현금 인출기)

비동기화 - 현재 실행 중인 명령이 종료되지 않아도 다음 명령 실행가능.
서버와 클라이언트가 주고 받는 것이 동시에 이루어지지 않는 형태.
시스템의 일치가 필요하지 않음.
수신하는 동안 다른 작업을 시행가능하여 버퍼링이 적음.
반응이 빠르기 때문에 여러 방면에서 사용 가능.

Try catch java run with resources
try { 
//예외발생할 가능성이 있는 문장 
}catch(Exception1 e1) { 
//Exception1이 발생했을 경우, 이를 처리하지 위한 문장
//보통 이곳에 예외메세지를 출력하고 로그로 남김
}catch(Exception2 e2) { 
//Exception2이 발생했을 경우, 이를 처리하지 위한 문장
}catch(ExceptionN eN) { 
//ExceptionN이 발생했을 경우, 이를 처리하지 위한 문장
}finally{ 
//예외발생여부에 관계없이 항상 수행되어야 하는 문장
}

에러와 예외의 차이는?
에러 - 컴퓨터 하드웨어의 오동작 또는 고장으로 인해 응용프로그램에 이상이 생겼거나 JVM 실행에 문제가 생겼을 경우 발생하는것.
예외 - 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류.

테스트코드 작성 방법, junit
프로젝트에 의존성을 추가한 다음 JUnit Test Case로 Test파일을 만든 후 import문으로 Test추가.
테스트 할 코드를 작성하고 작성한 코드 위에 @Test 사용. 
어노테이션나 메서드를 추가적으로 사용.

Annotation?
주석을 의미. @기호를 앞에 붙여서 사용.
컴파일러에게 코드 작성 문법 에러를 체크하도록 정보를 제공
소프트웨어 개발툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보 제공
실행시(런타임시)특정 기능을 실행하도록 정보를 제공

자바 thread 구현방법
Thread 클래스를 상속 or Runnable 인터페이스를 구현
// 1. Thread클래스를 상속
Class 상속받는클래스명 extends 상속하는클래스명 {
public void run() {작업내용} // Thread클래스의 run()을 오버라이딩
}

// 2. Runnable클래스를 상속
Class 상속받는클래스명 implements Runnable{
public void run() {작업내용} // Runnable인터페이스의 추상메서드 run()을 구현
}

Call by value Call by reference
Call by value - 값에 의한 호출. 
함수가 호출될 때 메모리 공간 안에서는 임시의 공간이 생성.
함수 호출시 전달되는 변수의 값을 복사하여 함수의 인자로 전달
JAVA의 경우 함수에 전달되는 인자의 데이터 타입에 따라서 (기본자료형 / 참조자료형 ) 함수 호출 방식이 달라짐.
기본 자료형 : call by value 로 동작 (int, short, long, float, double, char, boolean)

Call by reference - 참조에 의한 호출.
함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성. (함수 종료시 사라짐)
함수 안에서 인자의 값이 변경되면 함수 호출시에 있던 변수들도 값이 바뀜.
참조 자료형 : call by reference 로 동작 (Array, Class Instance)

Jvm 메모리 구조
이미지1
1. Method area (메소드 영역) - 클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보같은 필드 정보와 
메소드의 이름, 리턴 타입, 파라미터, 접근 제어자 정보같은 
메소드 정보, Type정보(Interface인지 class인지), 
Constant Pool(상수 풀 : 문자 상수, 타입, 필드, 객체 참조가 저장됨), 
static 변수, final class 변수등이 생성되는 영역.

2. Heap area (힙 영역) - new 키워드로 생성된 객체와 배열이 생성되는 영역.
메소드 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역.

3. Stack area (스택 영역) - 지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값등이 생성되는 영역이다.
int a = 10; 이라는 소스를 작성했다면 정수값이 할당될 수 있는 메모리공간을 a라고 잡아두고 그 메모리 영역에 값이 10이 들어간다. 
즉, 스택에 메모리에 이름이 a라고 붙여주고 값이 10인 메모리 공간을 만든다.
클래스 Person p = new Person(); 이라는 소스를 작성했다면 Person p는 스택 영역에 생성되고 new로 생성된 Person 클래스의 인스턴스는 힙 영역에 생성된다.
그리고 스택영역에 생성된 p의 값으로 힙 영역의 주소값을 가지고 있다. 
즉, 스택 영역에 생성된 p가 힙 영역에 생성된 객체를 가리키고(참조하고) 있는 것이다.
메소드를 호출할 때마다 개별적으로 스택이 생성된다.

4. PC Register (PC 레지스터) - Thread(쓰레드)가 생성될 때마다 생성되는 영역.
Program Counter 즉, 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역. (*CPU의 레지스터와 다름)
이것을 이용해서 쓰레드를 돌아가면서 수행할 수 있게 한다.

5. Native method stack - 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역.
보통 C/C++등의 코드를 수행하기 위한 스택이다. (JNI)

*쓰레드가 생성되었을 때 기준으로 메소드 영역과 힙 영역을 모든 쓰레드가 공유.
스택 영역과 PC 레지스터, Native method stack은 각각의 쓰레드마다 생성되고 공유되지 않음.

array, LIST, MAP, SET, tree 구분해서 설명
array - 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것. (배열)
List - 순서가 있는 데이터 집합. 저장순서가 있고 중복 가능.
Map - 키와 값의 쌍으로 이루어진 데이터 집합. 저장순서가 없고 중복은 값만 허용.
Set - 순서를 유지하지 않는 데이터의 집합. 저장순서가 없고 중복을 허용하지 않음.
tree - 계층적 구조를 띔. 부모노드와 자식노드가 있음. 주로 Set에 많이 사용.

